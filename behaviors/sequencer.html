<link rel="import" href="../../polymer/polymer-element.html">

<script>
    class Sequencer extends Polymer.Element {
        static get properties() {
            return {
<<<<<<< HEAD
                /**
                 * Current step on the sequence
                 * @type {Number}
                 */
                currentStep: {
                    type: Number,
                    value: 0
                },
                /**
                 * Sequence length
                 * @type {Number}
                 */
                length: {
                    type: Number,
                    value: 8
                },
                /**
                 * Notes on the sequence. Values from `0` to `1`.
                 * @type {Array}
                 */
                notes: {
                    type: Array,
                    value: () => {
                        return []
                    }
                },
                /**
                 * Active steps on the sequence. Values are booleans.
                 * @type {Array}
                 */
                activeSteps: {
                    type: Array,
                    value: () => {
                        return []
                    }
                },
                /**
                 * Gate input line.
                 * @type {Number}
                 */
                gateIn: {
                    type: Number,
                    value: 0,
                    observer: '_observeGate'
                },
                /**
                 * Threshold value to compute if `gateIn` is rising.
                 * @type {Number}
                 */
                gateThreshold: {
                    type: Number,
                    value: 0.5
                },
                /**
                 * Reset input line.
                 * @type {Number}
                 */
                reset: {
                    type: Number,
                    value: 0,
                    observer: '_observeReset'
                },
                /**
                 * Threshold value to compute if `reset` is rising.
                 * @type {Number}
                 */
                resetThreshhold: {
                    type: Number,
                    value: 0.5
                },
                /**
                 * Current value from the `activeSteps` for the `currentStep`
                 * @type {Number}
                 */
                gateOut: {
                    type: Number,
                    computed: '_computeGateOut(currentStep)',
                    notify: true
                },
                /**
                 * Current value from the `notes` for the `currentStep`
                 * @type {Number}
                 */
                noteOut: {
                    type: Number,
                    computed: '_computeNoteOut(currentStep)',
=======
                steps: {
                    type: Array,
                    value: () => {
                        return [0,0,0,0,0,0,0,0];
                    },
                    notify: true
                },
                stepCount: {
                    type: Number,
                    value: 8,
                    observer: '_observeStepCount'
                },
                stepIndex: {
                    type: Number,
                    value: 0,
                    notify: true
                },
                gate: {
                    type: Number,
                    value: 0,
                    observer: '_observeGate'
                },
                threshold: {
                    type: Number,
                    value: 0.5
                },
                output: {
                    type: Number,
                    computed: '_computeOutput(stepIndex, steps.*)',
>>>>>>> aae7fada978eade47a70ae8d0e4be30a80c41c52
                    notify: true
                }
            }
        }
<<<<<<< HEAD

        connectedCallback () {
            super.connectedCallback();
            // Fill `notes` with random values and `activeSteps` with `1`.
            let notes = [],
                activeSteps = [];
            for (let i = 0; i < this.length; i++) {
                notes.push(Math.random());
                activeSteps.push(Math.random()>0.5);
            }
            this.set('notes', notes);
            this.set('activeSteps', activeSteps);
        }

        /**
         * Observer for the `gate` input line. Increments `currentStep` on
         * rising edge.
         * @param {Number} newGate New value from `gate` input line
         * @param {Number} oldGate Old value from `gate` input line
         */
        _observeGate (newGate, oldGate) {
            // Rising value
            if (oldGate < this.gateThreshold && newGate > this.gateThreshold) {
                let nextStep = (this.currentStep + 1) % this.length;
                this.set('currentStep', nextStep);
            }
        }

        /**
         * Observer for the `reset` input line. Sets the `currentStep` to `0`
         * on rising edge.
         * @param {Number} newReset New value from `reset` input line
         * @param {Number} oldReset Old value from `reset` input line
         */
        _observeReset (newReset, oldReset) {
            // Rising value
            if (oldReset < this.resetThreshold && newReset > this.resetThreshold) {
                this.set('currentStep', 0);
            }
        }

        /**
         * Compute the value for the `activeSteps` based on the `currentStep`.
         * @param {Number} currentStep Current step.
         */
        _computeGateOut (currentStep) {
            return this.activeSteps[currentStep];
        }

        /**
         * Compute the value for the `notes` based on the `currentStep`.
         * @param {Number} currentStep Current step.
         */
        _computeNoteOut (currentStep) {
            return this.notes[currentStep]
=======
        _observeGate (current, previous) {
            // if (current > this.threshold && previous < this.threshold) {
            if (current > this.threshold) {
                let nextStep = (this.stepIndex + 1) % this.stepCount;
                this.set('stepIndex', nextStep);
            }
        }
        _observeStepCount (current) {
            if (current > this.steps.length) {
                for (let i = this.steps.length; i < current; i++) {
                    this.push('steps', 0);
                }
            } else if (current < this.steps.length) {
                let extra = this.steps.length - current;
                this.splice('steps', this.steps.length - extra, extra);
            }
        }
        _computeOutput(index, steps) {
            return steps.base[index];
>>>>>>> aae7fada978eade47a70ae8d0e4be30a80c41c52
        }
    }
</script>
